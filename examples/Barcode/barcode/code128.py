
encoding = (
'11011001100',
'11001101100',
'11001100110',
'10010011000',
'10010001100',
'10001001100',
'10011001000',
'10011000100',
'10001100100',
'11001001000',
'11001000100',
'11000100100',
'10110011100',
'10011011100',
'10011001110',
'10111001100',
'10011101100',
'10011100110',
'11001110010',
'11001011100',
'11001001110',
'11011100100',
'11001110100',
'11101101110',
'11101001100',
'11100101100',
'11100100110',
'11101100100',
'11100110100',
'11100110010',
'11011011000',
'11011000110',
'11000110110',
'10100011000',
'10001011000',
'10001000110',
'10110001000',
'10001101000',
'10001100010',
'11010001000',
'11000101000',
'11000100010',
'10110111000',
'10110001110',
'10001101110',
'10111011000',
'10111000110',
'10001110110',
'11101110110',
'11010001110',
'11000101110',
'11011101000',
'11011100010',
'11011101110',
'11101011000',
'11101000110',
'11100010110',
'11101101000',
'11101100010',
'11100011010',
'11101111010',
'11001000010',
'11110001010',
'10100110000',
'10100001100',
'10010110000',
'10010000110',
'10000101100',
'10000100110',
'10110010000',
'10110000100',
'10011010000',
'10011000010',
'10000110100',
'10000110010',
'11000010010',
'11001010000',
'11110111010',
'11000010100',
'10001111010',
'10100111100',
'10010111100',
'10010011110',
'10111100100',
'10011110100',
'10011110010',
'11110100100',
'11110010100',
'11110010010',
'11011011110',
'11011110110',
'11110110110',
'10101111000',
'10100011110',
'10001011110',
'10111101000',
'10111100010',
'11110101000',
'11110100010',
'10111011110',
'10111101110',
'11101011110',
'11110101110',
'11010000100',
'11010010000',
'11010011100',
'1100011101011',
)

code_A = (
' ',
'!',
'"',
'#',
'$',
'%',
'&',
'\'',
'(',
')',
'*',
'+',
',',
'-',
'.',
'/',
'0',
'1',
'2',
'3',
'4',
'5',
'6',
'7',
'8',
'9',
':',
';',
'<',
'=',
'>',
'?',
'@',
'A',
'B',
'C',
'D',
'E',
'F',
'G',
'H',
'I',
'J',
'K',
'L',
'M',
'N',
'O',
'P',
'Q',
'R',
'S',
'T',
'U',
'V',
'W',
'X',
'Y',
'Z',
'[',
'\\',
']',
'^',
'_',
'[NUL]',
'[SOH]',
'[STX]',
'[ETX]',
'[EOT]',
'[ENQ]',
'[ACK]',
'[BEL]',
'[BS]',
'[HT]',
'[LF]',
'[VT]',
'[FF]',
'[CR]',
'[SO]',
'[SI]',
'[DLE]',
'[DC1]',
'[DC2]',
'[DC3]',
'[DC4]',
'[NAK]',
'[SYN]',
'[ETB]',
'[CAN]',
'[EM]',
'[SUB]',
'[ESC]',
'[FS]',
'[GS]',
'[RS]',
'[US]',
'[FNC3]',
'[FNC2]',
'[SHIFT B]',
'[Code C]',
'[Code B]',
'[FNC4]',
'[FNC1]',
'[START A]',
'[START B]',
'[START C]',
'[STOP]',
)

code_B = (
' ',
'!',
'"',
'#',
'$',
'%',
'&',
'\'',
'(',
')',
'*',
'+',
',',
'-',
'.',
'/',
'0',
'1',
'2',
'3',
'4',
'5',
'6',
'7',
'8',
'9',
':',
';',
'<',
'=',
'>',
'?',
'@',
'A',
'B',
'C',
'D',
'E',
'F',
'G',
'H',
'I',
'J',
'K',
'L',
'M',
'N',
'O',
'P',
'Q',
'R',
'S',
'T',
'U',
'V',
'W',
'X',
'Y',
'Z',
'[',
'\\',
']',
'^',
'_',
'`',
'a',
'b',
'c',
'd',
'e',
'f',
'g',
'h',
'i',
'j',
'k',
'l',
'm',
'n',
'o',
'p',
'q',
'r',
's',
't',
'u',
'v',
'w',
'x',
'y',
'z',
'{',
'|',
'}',
'~',
'[DEL]',
'[FNC3]',
'[FNC2]',
'[SHIFT A]',
'[Code C]',
'[FNC4]',
'[Code A]',
'[FNC1]',
'[START A]',
'[START B]',
'[START C]',
'[STOP]',
)

code_C = (
'00',
'01',
'02',
'03',
'04',
'05',
'06',
'07',
'08',
'09',
'10',
'11',
'12',
'13',
'14',
'15',
'16',
'17',
'18',
'19',
'20',
'21',
'22',
'23',
'24',
'25',
'26',
'27',
'28',
'29',
'30',
'31',
'32',
'33',
'34',
'35',
'36',
'37',
'38',
'39',
'40',
'41',
'42',
'43',
'44',
'45',
'46',
'47',
'48',
'49',
'50',
'51',
'52',
'53',
'54',
'55',
'56',
'57',
'58',
'59',
'60',
'61',
'62',
'63',
'64',
'65',
'66',
'67',
'68',
'69',
'70',
'71',
'72',
'73',
'74',
'75',
'76',
'77',
'78',
'79',
'80',
'81',
'82',
'83',
'84',
'85',
'86',
'87',
'88',
'89',
'90',
'91',
'92',
'93',
'94',
'95',
'96',
'97',
'98',
'99',
'[Code B]',
'[Code A]',
'[FNC1]',
'[START A]',
'[START B]',
'[START C]',
'[STOP]',
)

encode_A = {}
encode_B = {}
encode_C = {}
decode_A = {}
decode_B = {}
decode_C = {}
for a, b, c, num in zip( code_A, code_B, code_C, range( len( code_A ) ) ):
	encode_A[a] = num
	encode_B[b] = num
	encode_C[c] = num
	decode_A[num] = a
	decode_B[num] = b
	decode_C[num] = c

def bestcode( input ):
	'''
	Find the optimal code 128 encoding of a given string.
	Returns a list of code indices (as numbers). To get the final encoding call binary() with this list as parameter.
	Runs in linear time using a DP approach.
	'''
	# this is our DP table:
	best_A = [(encode_A['[START A]'],)] + [None for i in range( len( input ) )]
	best_B = [(encode_B['[START B]'],)] + [None for i in range( len( input ) )]
	best_C = [(encode_C['[START C]'],)] + [None for i in range( len( input ) )]
	# for an input of length N we have a table of 3 rows and N+1 columns
	# the cell in row X and column Y contains the best encoding of the first Y characters that ends up in mode X

	def shortest( *args ):
		l = [(len( x ), x) for x in args if x is not None]
		if len( l ) == 0:
			return None
		else:
			return min( l )[1]
	def getbest( i ):
		return shortest( best_A[i], best_B[i], best_C[i] )
	for i in range( len( input ) ):
		rest = input[i:]
		bestlast = getbest( i )
		# if something can be encoded at the current position set the corresponding cell
		# possible contenders are:
		#	- the contents of the cell (best encoding for that situation so far)
		#	- the best encoding until the current position in our mode + the encoded symbol
		#	- the best encoding until the current position in some other mode + the mode switch + the encoded symbol
		for x in code_A:
			if rest.startswith( x ):
				best_A[i + len( x )] = shortest( best_A[i + len( x )], best_A[i] + (encode_A[x],), bestlast + (encode_B['[Code A]'], encode_A[x]) )
				# consider using this encoding via SHIFTing from B
				best_B[i + len( x )] = shortest( best_B[i + len( x )], best_B[i] + (encode_B['[SHIFT A]'], encode_A[x]) )
		for x in code_B:
			if rest.startswith( x ):
				best_B[i + len( x )] = shortest( best_B[i + len( x )], best_B[i] + (encode_B[x],), bestlast + (encode_C['[Code B]'], encode_B[x]) )
				# consider using this encoding via SHIFTing from A
				best_A[i + len( x )] = shortest( best_A[i + len( x )], best_A[i] + (encode_A['[SHIFT B]'], encode_B[x]) )
		for x in code_C:
			if rest.startswith( x ):
				best_C[i + len( x )] = shortest( best_C[i + len( x )], best_C[i] + (encode_C[x],), bestlast + (encode_A['[Code C]'], encode_C[x]) )

		bestnext = getbest( i + 1 )
		if bestnext is None: continue
		# if the next character can not be encoded in a mode we still have to fill that cell
		# possible contenders are:
		#	- the contents of the cell (best encoding for the situation so far)
		#	- best cell in this column (best encoding in some other mode) + the cost of switching to our mode
		best_A[i + 1] = shortest( best_A[i + 1], bestnext + (encode_B['[Code A]'],) )
		best_B[i + 1] = shortest( best_B[i + 1], bestnext + (encode_C['[Code B]'],) )
		best_C[i + 1] = shortest( best_C[i + 1], bestnext + (encode_A['[Code C]'],) )

	# the best encoding of the entire string is the best in the last column
	return getbest( len( input ) )

def binary( code ):
	'''
	Convert a list of code indices to a binary string.
	'''
	return ''.join( [encoding[x] for x in code] )

def decode( code, verbose = False ):
	'''
	Decode a coded string given as a list of code indices. For testing purposes.
	'''
	decode = decode_A
	nextdecode = decode
	for c in code:
		d = decode[c]
		decode = nextdecode
		if d == '[START A]' or d == '[Code A]':
			nextdecode = decode = decode_A
		elif d == '[START B]' or d == '[Code B]':
			nextdecode = decode = decode_B
		elif d == '[START C]' or d == '[Code C]':
			nextdecode = decode = decode_C
		elif d == '[SHIFT A]':
			nextdecode = decode
			decode = decode_A
		elif d == '[SHIFT B]':
			nextdecode = decode
			decode = decode_B
		elif not verbose:
			yield d
		if verbose:
			yield d

def checksum( code ):
	'''
	Calculate the checksum for a coded string given as a list of code indices.
	'''
	sum = code[0]
	for i in range( 1, len( code ) ):
		sum += i * code[i]
	return sum % 103

def encode( input ):
	'''
	Optimally encodes an input in code 128, complete with checksum and stop. Returns code as a binary string or None if no encoding can be found.
	'''
	encoded = bestcode( input )
	if encoded is None:
		return None
	return binary( encoded + (checksum( encoded ), encode_A['[STOP]']) )

if __name__ == '__main__':
	import sys
	encoded = bestcode( sys.argv[1] )
	print sys.argv[1]
	print 'encoded:', encoded
	print 'decoded:', [x for x in decode( encoded, verbose = True )]
	print 'checksum:', checksum( encoded )
	print 'binary:', encode( sys.argv[1] )

